import type { SemanticPhase, SemanticSignalGroup, SignalConfidence } from "../store/transcriptTypes.ts";

export type TranscriptSignalProvider = "claude" | "codex";

export interface TranscriptSignalDefinition {
  provider: TranscriptSignalProvider;
  key: string;
  group: SemanticSignalGroup;
  phase: SemanticPhase;
  // Human-readable matcher string for debugging and manual validation.
  pattern: string;
  description: string;
  confidence: SignalConfidence;
  driftRisk: "low" | "medium" | "high";
}

// Claude transcript signals grouped by lifecycle intent.
export const CLAUDE_SIGNAL_DEFINITIONS: readonly TranscriptSignalDefinition[] = [
  {
    provider: "claude",
    key: "claude.turn.dequeue",
    group: "turn",
    phase: "thinking",
    pattern: "type == 'queue-operation' && operation == 'dequeue'",
    description: "Claude dequeued a new turn from the request queue.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.turn.user_message",
    group: "turn",
    phase: "thinking",
    pattern: "type == 'user'",
    description: "A user turn was recorded in the transcript.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.assistant.thinking_block",
    group: "thinking",
    phase: "thinking",
    pattern: "assistant message contains content[].type == 'thinking'",
    description: "Claude emitted explicit thinking content.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.assistant.redacted_thinking",
    group: "thinking",
    phase: "thinking",
    pattern: "assistant message contains content[].type == 'redacted_thinking'",
    description: "Claude emitted safety-redacted thinking content.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.assistant.tool_use",
    group: "tooling",
    phase: "tooling",
    pattern: "assistant message contains content[].type == 'tool_use'",
    description: "Claude requested a tool call.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.assistant.server_tool_use",
    group: "tooling",
    phase: "tooling",
    pattern: "assistant message contains content[].type == 'server_tool_use'",
    description: "Claude requested an MCP server tool call.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "claude",
    key: "claude.user.tool_result",
    group: "tooling",
    phase: "tooling",
    pattern: "user message contains content[].type == 'tool_result'",
    description: "Claude received tool output.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.assistant.text",
    group: "response",
    phase: "responding",
    pattern: "assistant message contains non-empty content[].type == 'text'",
    description: "Claude emitted user-visible response text.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.progress.agent",
    group: "thinking",
    phase: "thinking",
    pattern: "type == 'progress' && data.type == 'agent_progress'",
    description: "Claude emitted sub-agent progress heartbeat.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "claude",
    key: "claude.progress.hook",
    group: "tooling",
    phase: "tooling",
    pattern: "type == 'progress' && data.type == 'hook_progress'",
    description: "Claude emitted hook progress around tool execution.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "claude",
    key: "claude.lifecycle.result",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type == 'result'",
    description: "Claude turn completed with result metadata.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "claude",
    key: "claude.lifecycle.compaction",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type/subtype == 'CompactBoundaryMessage'",
    description: "Claude compacted transcript and rotated file.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "claude",
    key: "claude.lifecycle.system_error",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type == 'system' && contains error/warning",
    description: "Claude system error or warning event.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "claude",
    key: "claude.lifecycle.api_error",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type == 'api_error' || error object present",
    description: "Claude API error event.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "claude",
    key: "claude.lifecycle.summary",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type == 'summary'",
    description: "Claude compaction summary (newer format).",
    confidence: "high",
    driftRisk: "medium",
  },
] as const;

// Codex rollout signals grouped by lifecycle intent.
export const CODEX_SIGNAL_DEFINITIONS: readonly TranscriptSignalDefinition[] = [
  {
    provider: "codex",
    key: "codex.turn.started",
    group: "turn",
    phase: "thinking",
    pattern: "type == 'turn.started'",
    description: "Codex started processing a turn.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "codex",
    key: "codex.response.reasoning",
    group: "thinking",
    phase: "thinking",
    pattern: "type == 'response_item' && payload.type == 'reasoning'",
    description: "Codex emitted reasoning summary metadata.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "codex",
    key: "codex.response.function_call",
    group: "tooling",
    phase: "tooling",
    pattern: "type == 'response_item' && payload.type == 'function_call'",
    description: "Codex requested a tool/function call.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "codex",
    key: "codex.response.function_call_output",
    group: "tooling",
    phase: "tooling",
    pattern: "type == 'response_item' && payload.type == 'function_call_output'",
    description: "Codex received function call output.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "codex",
    key: "codex.response.assistant_message",
    group: "response",
    phase: "responding",
    pattern: "type == 'response_item' && payload.type == 'message' && payload.role == 'assistant'",
    description: "Codex emitted assistant response text.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "codex",
    key: "codex.response.web_search",
    group: "tooling",
    phase: "tooling",
    pattern: "type == 'response_item' && payload.type == 'web_search_call'",
    description: "Codex requested a web search.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "codex",
    key: "codex.response.file_search",
    group: "tooling",
    phase: "tooling",
    pattern: "type == 'response_item' && payload.type == 'file_search_call'",
    description: "Codex requested a file search.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "codex",
    key: "codex.event.agent_message",
    group: "response",
    phase: "responding",
    pattern: "type == 'event_msg' && payload.type == 'agent_message'",
    description: "Codex emitted assistant message event.",
    confidence: "medium",
    driftRisk: "medium",
  },
  {
    provider: "codex",
    key: "codex.event.user_input_request",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type == 'event_msg' && payload.type in {'request_user_input','elicitation_request'}",
    description: "Codex requested user input or elicitation.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "codex",
    key: "codex.turn.completed",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type == 'turn.completed'",
    description: "Codex turn completed.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "codex",
    key: "codex.lifecycle.turn_failed",
    group: "lifecycle",
    phase: "waiting",
    pattern: "type == 'turn.failed'",
    description: "Codex turn failed with error.",
    confidence: "high",
    driftRisk: "low",
  },
  {
    provider: "codex",
    key: "codex.lifecycle.context_compacted",
    group: "lifecycle",
    phase: "thinking",
    pattern: "type == 'context.compacted'",
    description: "Codex context window was compacted.",
    confidence: "high",
    driftRisk: "medium",
  },
  {
    provider: "codex",
    key: "codex.legacy.item_started",
    group: "tooling",
    phase: "tooling",
    pattern: "type == 'item.started' && item.type in {command_execution,function_call}",
    description: "Legacy Codex schema command started.",
    confidence: "high",
    driftRisk: "high",
  },
  {
    provider: "codex",
    key: "codex.legacy.item_completed",
    group: "tooling",
    phase: "tooling",
    pattern: "type == 'item.completed'",
    description: "Legacy Codex schema command completed.",
    confidence: "high",
    driftRisk: "high",
  },
] as const;

const SIGNAL_INDEX = new Map<string, TranscriptSignalDefinition>(
  [...CLAUDE_SIGNAL_DEFINITIONS, ...CODEX_SIGNAL_DEFINITIONS]
    .map((signal) => [signal.key, signal]),
);

export function getTranscriptSignalDefinition(key: string): TranscriptSignalDefinition | null {
  return SIGNAL_INDEX.get(key) ?? null;
}
